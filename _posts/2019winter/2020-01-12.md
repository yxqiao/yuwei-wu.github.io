### 1. nlogn sort
merge sort
quick sort


### 2 
#### HashTable
底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化
初始size为11，扩容：newsize = olesize*2+1   
计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length    

#### HashMap
底层数组+链表实现，可以存储null键和null值，线程不安全    
初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂    
扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入       
插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）    
当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀     
计算index方法：index = hash & (tab.length – 1)    


HashMap的初始值还要考虑加载因子:

 哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。
加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。
空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。
